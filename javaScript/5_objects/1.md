<div style="text-align: justify">

# 1. Working with Objects

## 1.1. What is a JavaScript object and how can you access properties from an object?

In JavaScript, an object is a fundamental data structure that allows you to store and organize related data and functionality. You can think of an object as a container that holds various pieces of information, much like a filing cabinet holds different folders and documents.

These pieces of information are called properties, and they consist of a name (or key) and a value.

```js
const exampleObject = {
  propertyName: value;
}
```

Objects are incredibly versatile and form the backbone of JavaScript. In fact, almost everything in JavaScript is an object or can be treated as one. This includes arrays, functions, and even primitive data types like strings and numbers when used in certain ways.

This object-centric nature of JavaScript is one of the reasons it's such a flexible and powerful language. Let's look at how you can create an object:

```js
const person = {
  name: "Alice",
  age: 30,
  city: "New York"
};
```

In this example, we've created an object called `person` with three properties: `name`, `age`, and `city`. Each property has a name and a value, separated by a colon.

Now, let's explore how you can access these properties. There are two main ways to access object properties in JavaScript: dot notation and bracket notation.

1. Dot notation is the most common and straightforward way to access object properties. Here is the basic syntax for dot notation:

    ```js
    objectName.propertyName
    ```

    Here's how you would use dot notation with our `person` object:

    ```js
    const person = {
        name: "Alice",
        age: 30,
        city: "New York"
    };

    console.log(person.name);  // Alice
    console.log(person.age);   // 30
    ```

    Dot notation is concise and easy to read, making it the preferred choice when you know the exact name of the property you want to access and that name is a valid JavaScript identifier (meaning it doesn't start with a number and doesn't contain special characters or spaces).

2. Bracket notation, on the other hand, allows you to access object properties using a string inside square brackets. Here's how you would use bracket notation:

    ```js
    const person = {
        name: "Alice",
        age: 30,
        city: "New York"
    };

    console.log(person["name"]); // Alice
    console.log(person["age"]); //  30
    ```

    Bracket notation is more flexible than dot notation because it allows you to use property names that aren't valid JavaScript identifiers. For example, if you had a property name with spaces or that starts with a number, you'd need to use bracket notation:

    ```js
    const oddObject = {
        "1stProperty": "Hello",
        "property with spaces": "World"
    };

    console.log(oddObject["1stProperty"]);  // Hello
    console.log(oddObject["property with spaces"]);  // World
    ```

    Another advantage of bracket notation is that it allows you to use variables to access properties dynamically:

    ```js
    const person = {
        name: "Alice",
        age: 30,
        city: "Wonderland"
    };

    let propertyName = "city";
    console.log(person[propertyName]); // Wonderland
    ```

    This flexibility makes bracket notation particularly useful when you don't know the exact property name at the time you're writing the code, or when you're working with property names that come from user input or some other dynamic source.

It's worth noting that objects in JavaScript are incredibly powerful and versatile. They can contain not just simple values like strings and numbers, but also arrays, or other objects.

Understanding objects and how to work with them is crucial in JavaScript because they're used extensively throughout the language and in many JavaScript libraries and frameworks.

As you continue to learn and work with JavaScript, you'll find that mastering objects opens up a world of possibilities for creating complex and powerful applications.

## 1.2. What is object destructuring and how does it work?

Object destructuring is a powerful feature in JavaScript that allows you to extract values from objects and assign them to variables in a more concise and readable way. It's part of the ES6 (ECMAScript 2015) specification and has become an essential tool for many JavaScript developers.

Destructuring can simplify your code, especially when working with complex objects or when you need to extract multiple values at once.

At its core, object destructuring is about unpacking values from objects into distinct variables. Instead of accessing object properties one by one, you can extract multiple properties in a single statement. This can make your code cleaner and more efficient.

Let's start with an example to illustrate how object destructuring works:

```js
const person = { name: "Alice", age: 30, city: "New York" };

const { name, age } = person;

console.log(name); // Alice
console.log(age);  // 30
```

In this example, we're extracting the `name` and `age` properties from the `person` object and assigning them to variables with the same names.

One of the powerful aspects of object destructuring is that you can assign the extracted values to variables with different names. This is particularly useful when you're working with objects that have property names that might conflict with existing variables or when you want to use a different name:

```js
let person = { name: "Alice", age: 30, city: "New York" };

let { name: personName, age: personAge } = person;

console.log(personName); // Alice
console.log(personAge); //  30
```

In this case, we're extracting the `name` property and assigning it to a variable called `personName`, and doing the same with `age` and `personAge`.

Object destructuring also allows you to set default values. If a property doesn't exist in the object you're destructuring, you can specify a fallback value:

```js
let person = { name: "Alice", age: 30, city: "New York" };
let { name, age, country = "Unknown" } = person;

console.log(country); // Unknown
```

Here, since `country` doesn't exist in our `person` object, it gets the default value `Unknown`.

Now, let's talk about the shorthand notation in object destructuring. When you're creating objects, especially when the property names match variable names, you can use a shorthand syntax:

```js
let name = "Bob";
let age = 25;

let person = { name, age };

console.log(person); // { name: "Bob", age: 25 }
```

The code above takes the properties with the same name as our variables and assigns them the values of those variables.

This shorthand notation is particularly useful when you're returning objects from functions or creating objects with multiple properties:

```js
function createPerson(name, age) {
  return { name, age };
}

let person = createPerson("Charlie", 35);
console.log(person); // { name: "Charlie", age: 35 }
```

Object destructuring and the shorthand object notation are powerful features that can make your code more concise and easier to read. They're especially useful when working with complex data structures, or when you need to pass multiple parameters to functions.

## 1.3. How can you remove properties from an object?

1. There are several ways to remove properties from an object, with the `delete` operator being the most straightforward and commonly used method.

    When you use `delete`, it removes the selected property from the object. Here's an example of how to use the `delete` operator:

    ```js
    const person = {
        name: "Alice",
        age: 30,
        job: "Engineer"
    };

    delete person.job;

    console.log(person.job); // undefined

    console.log(person);     // {name: "Alice", age: 30}
    ```

    In this example, we start with a `person` object that has three properties: `name`, `age`, and `job`. Then, we use the `delete` operator to remove the `job` property. After the deletion, the `person` object no longer has the `job` property.

2. Another way to remove properties is by using destructuring assignment with rest parameters. This approach doesn't actually delete the property, but it creates a new object without the specified properties:

    ```js
    const person = {
        name: "Bob",
        age: 25,
        job: "Designer",
        city: "New York"
    };

    const { job, city, ...remainingProperties } = person;

    // { name: "Bob", age: 25 }
    console.log(remainingProperties);
    ```

    In this example, we use destructuring to extract `job` and `city` from the `person` object, and collect the remaining properties into a new object called `remainingProperties`. This creates a new object without the `job` and `city` properties.

## 1.4. How to check if an object has a property?

In JavaScript, there are several ways to check if an object has a specific property. Understanding these methods is important for working effectively with objects, especially when you're dealing with data from external sources or when you need to ensure certain properties exist before using them.

We'll explore three common approaches: the `hasOwnProperty()` method, the `in` operator, and checking against `undefined`.

1. Let's start with the `hasOwnProperty()` method. This method returns a boolean indicating whether the object has the specified property as its own property. Here's an example:

    ```js
    const person = {
        name: "Alice",
        age: 30
    };

    console.log(person.hasOwnProperty("name")); // true
    console.log(person.hasOwnProperty("job")); // false
    ```

    In this example, we have an object called `person` with two properties: `name` and `age`. To check if `name` is a property in the `person` object, we use the `hasOwnProperty()` method. Since `name` is a property, it will return `true`. But when we use the `hasOwnProperty()` to check if `job` is a property, it will return `false` because it does not exist in the object.

2. Another way to check for the existence of a property in an object is to use the `in` operator. Like `hasOwnProperty()`, the `in` operator will return `true` if the property exists on the object. Here's how you can use it:

    ```js
    const person = {
        name: "Bob",
        age: 25
    };
    console.log("name" in person);  // true
    ```

    In this example, `"name" in person` returns `true` because `name` is a property of `person`.

3. The third method involves checking if a property is `undefined`. This approach can be useful, but it has some limitations. Here's an example:

    ```js
    const car = {
        brand: "Toyota",
        model: "Corolla",
        year: 2020
    };

    console.log(car.brand !== undefined); // true
    console.log(car.color !== undefined); // false
    ```

    In this code, we check if `car.brand` and `car.color` are not `undefined`. This works because accessing a non-existent property on an object returns `undefined`. However, this method can give false negatives if a property explicitly has the value `undefined`.

In practice, the choice between these methods often depends on the specific requirements of your code. Understanding the differences between them will help you make the right choice in different scenarios.

</div>